---
title: "Uniswap Conceptually"
author: "Carlos Mercado"
date: "`r Sys.Date()`"
output:
  html_document:
    code_folding: hide
editor_options: 
  chunk_output_type: console
---

# Intro

Uniswap v2 is an automatic market maker that pools deposits of 2 tokens, here we will assume Ether (ETH) and wrapped Bitcoin (wBTC), and allows anyone to autonomously trade between the assets using that pool by paying a fee, e.g., 0.3%.

To do this, it takes both extreme relative prices:

-   1 ETH = 0 BTC
-   1 ETH = Infinite BTC

And uses a constant product function `x * y = k` to calculate how much of token x to provide to traders looking to offload token y. Note this is separate from the 0.3% fee. All trades, but especially large trades, *impact the relative price* of the tokens when trading, this is called price impact.

# Simulated WBTC-ETH Uniswap v2 Pool

For example, assume the current price of 1 ETH is 0.1 WBTC and that a liquidity pool exists with 1,000 ETH and 100 WBTC. This means the constant product `k = 1000*100 = 100,000`

Any trade is allowable as long as the resulting balance of X ETH and Y WBTC remains 100,000. Notice how US Dollar prices are not relevant. It is only the constant product enforcing relative prices that matters.

```{r, warning=FALSE, message=FALSE, fig.show='hide'}
options(scipen = 20)
library(dplyr)
library(plotly)
library(reactable)

kfunc <- function(x, k = 100000){
  # returns y for an x that meets condition x*y = k
 y = k/x
 return(y)
}


# draws plot and returns values 
# This plots by default: suppressing this to only get data.
x <- curve(kfunc, 0, 1000, n = 1001, xlab = 'BTC', ylab = 'ETH')
```

```{r,  warning=FALSE, message=FALSE}
pool <- data.frame(
  btc = x$x,
  eth = x$y
)

# for simplicity focus in on 100 BTC range
relevant_pool <- pool[50:180, ]

plot_ly(relevant_pool, x = ~btc) %>% 
  add_trace(y = ~eth, mode = 'lines', type = 'scatter', name = 'Constant Product') %>% 
  add_trace(x = ~100, y = ~1000, type = 'scatter', mode = 'markers', name = 'Current Price') %>% 
  layout(title = "Close up of Constant Product Curve around 100 BTC",
         annotations = list(x = 105, y = 1100,
                            text = 'Current Price',
                            showarrow = FALSE))
  
```

The orange point denotes the current (relative) price 1 ETH = 0.1 BTC, or more specifically 100 BTC = 1,000 ETH. But to *trade* with the pool *causes* a change in the price.

Reviewing the table form of the 95 - 105 BTC range where k = 100,000 shows the price point of several potential trades.

```{r,  warning=FALSE, message=FALSE}
price_snippet <- pool[96:106, ]
price_snippet$btc_delta <- price_snippet$btc - 100
price_snippet$eth_delta <- price_snippet$eth - 1000
price_snippet <- price_snippet %>% round(4) # 4 decimals

reactable(price_snippet %>% round(3), defaultPageSize = 25)
```

If you have 1 BTC and want ETH you would change the pool balance from:

-   100 BTC and 1000 ETH

to

-   101 BTC and 990.099 ETH

Meaning that although the price *was* 0.1 BTC per ETH originally. You actually only get `r 1000 - 990.099` ETH for your 1 BTC (would be less after any fee, e.g., 0.3%). This is the *price impact* mentioned previously. Instead of 0.1 BTC per ETH, you pay 0.10099 BTC per ETH. a **0.99%** price impact.

In the other direction if you want 5 BTC you would need to provide 52.6316 ETH to change the pool's composition to 95 BTC (and 1,052.6316 ETH). Instead of 0.1 BTC per ETH, you only get 0.09499 BTC per ETH. A **5.01%** price impact.

The larger the trade (5 BTC instead of 1 BTC) the worse the price impact.

The solution to this is to widen the curve by deepening the liquidity available. If instead the pool was 10,000 BTC and 100,000 ETH, trades of 1 BTC or even 5 BTC would be much closer to 0.1 BTC per ETH (it would not be exact because price impact still occurs).

# Real World WBTC-ETH Uniswap v2 Pool

Looking at the [Uniswap v2 ETH/WBTC pool](https://v2.info.uniswap.org/pair/0xbb2b8038a1640196fbe3e38816f3e67cba72d940%3E) analytics page.

![Example Screenshot from 2022-09-18](v2_wbtc_eth_screenshot.png){width="300"}

245.7565 WBTC and 3,532 ETH are in this pool. This is a relative price of 0.06957 BTC per ETH. Bitcoin is doing better against ETH than in the fake example above.

The constant product `k = 245.7565 * 3532 = 868,012`. This makes the real pool significantly more *deep* than in the fake intro example. So price impacts should be much smaller!

The constant product curve for the real pool is here:

```{r, fig.show='hide'}

x_real <- curve(kfunc(x, k = 868012), 200, 300, n = 100000, xlab = 'BTC', ylab = 'ETH', add = FALSE)

```

```{r,  warning=FALSE, message=FALSE}
pool_real <- data.frame(
  btc = x_real$x,
  eth = x_real$y
)

plot_ly(pool_real, x = ~btc) %>% 
  add_trace(y = ~eth, mode = 'lines', type = 'scatter', name = 'Constant Product') %>% 
  add_trace(x = ~245.7565, y = ~3532, type = 'scatter', mode = 'markers', name = 'Current Price') %>% 
  layout(title = "Close up of Constant Product Curve around 245 BTC",
         annotations = list(x = 255, y = 3590,
                            text = 'Current Price',
                            showarrow = FALSE))
```

Unlike before, because this pool is deeper a move of 1 BTC is much more easily absorbed.

```{r,  warning=FALSE, message=FALSE}
one_increments <- pool_real[seq(from = 40757, 50757, by = 1000), ]

one_increments$btc_delta <- one_increments$btc - 245.7565
one_increments$eth_delta <- one_increments$eth - 3532
one_increments <- one_increments %>% round(2) # 3 decimals
reactable(one_increments)
```

Selling 1 BTC to force the pool from 245.7565 to 246.7565 would remove 14.3131 ETH form the pool. This `r 1/14.3131` BTC per ETH is very close to the original relative price of 0.06957 BTC per ETH, only a **0.42%** price impact.

In the other direction if you want 5 BTC you would need to provide 73.3537 ETH. This `r 5/73.3537` BTC per ETH a **2.02%** price impact.

## Real World Uniswap v2 Confirmation

The 245.7565 WBTC; 3,532 ETH V2 Pool was as of Block 15,562,988. [This transaction](https://etherscan.io/tx/0x1f23e1feb1def28e5b5c7c4800dc66ff8338e114657593d08d9c6891471806d5) shows a trade of 1.3159 ETH for 0.0913 BTC in that block.

The constant product math with `k = 868,012` including the 0.3% fee would expect the following result:

`( 3532 - (1.3159*0.997) ) * (245.7565 + x) = 868,012`

Where the expected 0.0913 matches the transaction.

x = `round(868012/(3532 - 1.3159*0.997) - 245.7565, 4)`

x = `r round(868012/(3532 - 1.3159*0.997) - 245.7565, 4)`

Rounding, in addition to the possibility of *other trades* happening in the same block before this transaction (blocks are comprised on transactions and transactions within a block go in order) affecting the pool could lead to small differences in the expected and actual results. But our calculation and the real world matched to 4 significant digits.

# Simulated WBTC-ETH Uniswap v3 Pool

Uniswap v3 introduces *concentrated liquidity*. Instead of 1 pool covering all the extreme price ranges:

-   1 ETH = 0 BTC
-   1 ETH = Infinite BTC

Users individually provide target ranges, e.g.,

-   Minimum Price: 0.05 BTC/ETH => 1 ETH = 0.05 BTC (1 ETH *only* gets 0.05 BTC)
-   Maximum Price: 0.25 BTC/ETH => 1 ETH = 0.25 BTC (1 ETH gets 5 times as much: 0.25 BTC)

It can be tricky to think about these as minimums and maximums. It may help to recall that Automated Market Makers sell winners to buy losers and charge a fee for doing so. So as ETH rises in value (1 ETH buys more BTC) the liquidity pool, given a constant product, becomes disproportionately full of BTC instead of ETH.

In the extreme case, if the 100 BTC 1,000 ETH Liquidity Pool with 1 ETH = 0.1 BTC price mentioned above shifted to 1 ETH = 10 BTC, the pool would have to flip to 1,000 BTC and 100 ETH. The BTC comes from sellers of BTC who buy ETH: forcing the pool's balance to change (because of constant product).

Recall the Simulated 100 BTC; 1000 ETH liquidity pool from before but this time with two prices on the range noted: 1 ETH = 0.05 BTC and 1 ETH = 0.25 BTC.

```{r, warning=FALSE, message=FALSE}

p_func <- function(k = 100000, p = 0.05){
  # x * y = k
  # p = x/y
  # x = py
  # py * y = k
  # y = sqrt(k/p)
  # x = py
  
  y = sqrt(k/p)
  x = p*y
  
  return(
    list(x = x, y = y)
  )
}

low = p_func(k = 100000, p = 0.05)
high = p_func(k = 100000, p = 0.25)

plot_ly(relevant_pool, x = ~btc) %>% 
  add_trace(y = ~eth, mode = 'lines', type = 'scatter', name = 'Constant Product') %>% 
  add_trace(x = ~low$x, y = ~low$y, mode = 'markers', name = '1 ETH = 0.05 WBTC') %>%
  add_trace(x = ~high$x, y = ~high$y, mode = 'markers', name = '1 ETH = 0.25 WBTC') %>%
  add_trace(x = ~100, y = ~1000, type = 'scatter', mode = 'markers', name = 'Current Price') %>% 
  layout(title = "\n Constant Product with Ranges",
         annotations = list(x = 115, y = 1050,
                            text = 'Current Price',
                            showarrow = FALSE)) %>% 
  layout(
    xaxis = list(
      range=c(0,180)
    )
  )

```

In Uniswap v3, liquidity providers choose their range (e.g., Min 1 ETH = 0.05 BTC to Max 1 ETH = 0.25 BTC) and spread their liquidity (i.e., tradeability between two tokens) across the range. When someone is out of range (e.g., if 1 ETH = 0.049 BTC) their position is 100% in the lower value asset (they sold all their winners to buy the trader's losers with the hope their share of fees makes up for the loss).

## Understanding Uni v3 Ticks

Ticks act like 'buckets' of liquidity pooled from multiple providers. As trades occur, price impact happens using the same x*y = k formula within a tick. Ticks become exhausted of liquidity as price impact moves pushes the relative prices into other buckets of liquidity (i.e., across ticks).

This range is spread across ticks where each (integer) tick `i` is tracked with the formula:

`sqrt(price[i]) = sqrt(1.0001)^[i]`

Ticks are *not* the same size. They are 0.01% apart from their neighboring ticks!

Although we target a price range of 0.05 and 0.25, in actuality, the exact ticks need to fit within the tick spacing of the pool (which varies by fee tier).

For the ETH-WBTC 0.3% Fee Tier we would choose whichever range is as close as possible to our desired range while still being an integer of ticks and meeting the required tick spacing (60 for this pool on Ethereum). In addition to this tick spacing, for any pool, differences in the allowable decimals of the tokens will require a decimal adjustment.

Most ERC20 that are not stablecoins use 18 decimals and won't require an adjustment with ETH. But wrapped Bitcoin, WBTC, has 8 decimals to mimic Bitcoin; while ETH has 18. Thus, a 1e10 (18-8 = 10) decimal adjustment is needed.

For a USDC-WETH pool; USDC has 6 decimals. Thus, a 1e12 (18 - 6 = 12) decimal adjustment is needed.

Tick spacing matters significantly and changes by price tier. The USDC-WETH 0.3% pool has a 60 tick spacing just like the WBTC-ETH 0.3% pool; while the USDC-WETH 0.05% pool has a 10 tick spacing. For every analysis, getting the correct pool specific decimal adjustments and tick spacing are critical.

```{r,  warning=FALSE, message=FALSE}

tick_to_price <- function(tick, decimal_adjustment = 1){
  sqrt(1.0001)^(2*tick) * decimal_adjustment
}

get_closest_tick <- function(desired_price, tick_spacing = 60, decimal_adjustment = 1){
# base = sqrt(1.0001)
# y = sqrt(price / decimal_adjustment)
# base^tick = y
# tick = log(y, base)
# price = decimal_adjustment*(base^tick)^2

r <- list(
  desired_price = desired_price,
  actual_price = NULL,
  tick = NULL
)
    
initial_tick <- log( sqrt(desired_price / decimal_adjustment), sqrt(1.0001) )  

if(initial_tick %% tick_spacing == 0){
  r$actual_price <- desired_price # exact match
  r$tick <- initial_tick
} else { 
  final_tick <- round(initial_tick / tick_spacing)*tick_spacing
  r$tick <- final_tick 
  r$actual_price <- sqrt(1.0001)^(2*final_tick) * decimal_adjustment
}

return(r)
    
}

# WBTC has 8 decimals while WETH has 18
# So they have a 1e10 decimal adjustment factor
reactable(
  rbind(
    as.data.frame(get_closest_tick(0.05, decimal_adjustment = 1e10)),
    as.data.frame(get_closest_tick(0.25, decimal_adjustment = 1e10))
  )
)

```

Spreading liquidity evenly across ticks results in a uniform distribution of liquidity across ticks. But the *amount* of tokens to reach a desired liquidity (to then spread) across a concentrated range depends **on the current price**.

To get a simple result, let's assume we have 12.549 ETH and we need to know how much BTC to match it for our desired 0.05 BTC/ETH - 0.25 BTC/ETH range.

-   x = ?? BTC
-   y = 12.549 ETH
-   Current Price: x/y = 0.1 BTC/ETH
-   min price (for ETH), pa = 0.05 BTC/ETH (ETH is LOW, you only get 0.05 BTC for 1 ETH, we are 100% ETH at this price)
-   max price (for ETH), pb = 0.25 BTC/ETH (ETH is HIGH, you get 0.25 BTC for 1 ETH, we are 100% BTC at this price)

```{r}

match_x_to_y <- function(y, P, pa, pb){
  #' Given a current price P, number of tokens y, and price ranges pb and pa
  #' A required amount of x tokens can be calculated. 
  #' Lx = x * sqrt(P \* Pb) / ( sqrt(Pb) - sqrt(P) )
  #' y = Lx * ( sqrt(P) - sqrt(Pa) )
  
  r <- list(
    amount_y = y,
    current_price = P,
    min_price = pa, 
    max_price = pb,
    required_x = NULL
    
  )
  
  Ly = y * sqrt(P * pb) / ( sqrt(pb) - sqrt(P) )
  x = Ly * ( sqrt(P) - sqrt(pa) )
  
  r$required_x = x
  
  return(r)
}

reactable(
  as.data.frame(
    match_x_to_y(y = 12.549, P = 0.1, pa = 0.05, pb = 0.25)
  )
)

```

This range needs 1 BTC to match with 12.549 ETH (this number was chosen on purpose).

To show the process in reverse, if we had 1 BTC and needed to know how much ETH we needed to concentrate into the 0.05 BTC/ETH - 0.25 BTC/ETH range at a 0.1 BTC/ETH Current Price, everything has to be **inverted**.

-   max ETH price 0.25 BTC/ETH becomes minimum BTC price -> 4 ETH/BTC
-   min ETH price 0.05 BTC/ETH becomes max BTC price -> 20 ETH/BTC
-   price is inverted 0.1 BTC/ETH -> 10 ETH/BTC

-   x = 1 BTC
-   y = ?? ETH
-   Current Price, y/x = 10 ETH/BTC
-   min price (for BTC), pa = 4 ETH/BTC (BTC is LOW, you only get 4 ETH per BTC, we are 100% BTC at this price)
-   max price (for BTC), pb = 20 ETH/BTC (BTC is HIGH, you get 5x as much ETH per BTC, we are 100% ETH at this price)

```{r}

match_y_to_x <- function(x, P, pa, pb){
  #' Given a current price P, number of tokens x, and price ranges pb and pa
  #' A required amount of y tokens can be calculated. 
  #' Lx = x * sqrt(P \* Pb) / ( sqrt(Pb) - sqrt(P) )
  #' y = Lx * ( sqrt(P) - sqrt(Pa) )
  
  r <- list(
    amount_x = x,
    current_price = P,
    min_price = pa,
    max_price = pb,
    required_y = NULL
    
  )
  
  Lx = x * sqrt(P * pb) / ( sqrt(pb) - sqrt(P) )
  y = Lx * ( sqrt(P) - sqrt(pa) )
  
  r$required_y = y
  
  return(r)
}

reactable(
  as.data.frame(
match_y_to_x(x = 1, # 1 BTC, 
             P = 10, # 10 ETH per BTC
             pa = 4, # 4 ETH per BTC, BTC IS LOW
             pb = 20 # 20 ETH per BTC, BTC is HIGH
             )
  )
)

```

The desired range would require ~12.549 ETH per BTC deposited (it scales linearly w/ more BTC given same price and range).

Your choice of *unit of account* (i.e., choice of price = y/x or x/y) determines how we define minimum and maximum for a range. Whichever way you choose to account for and calculate these ranges, it helps to pick one and stay consistent. In line with the original White Paper, BTC/ETH (i.e., x/y) has been the preferred method unit of account ratio in this paper, but inversions will be noted as needed to align to available math derived from other sources.

## Capital Efficiency & Range Selection

Reviewing the original 100 BTC, 1000 ETH Uni V2 pool with a 0.1 BTC/ETH current price. Concentration to the 0.05 - 0.25 BTC/ETH range and keeping the 0.1 BTC/ETH current price means that 1000 ETH can be matched with *only* `r match_x_to_y(y = 1000, P = 0.1, pb = 0.25, pa = 0.05)$required_x` BTC.

This is *capital efficiency*. Instead of providing 100 BTC and 1000 ETH to the 0 - Infinite range of Uniswap v2 at 0.1 BTC/ETH each. Uniswap v3 allows for less tokens (1000 ETH, 79.689 BTC) to be used to provide more liquidity (per unit) at the price.

Although in this case the total amount of liquidity is slightly smaller (1000 * 79.689 < 1000 * 100), it is more efficient.

```{r}
reactable(
  as.data.frame(
    match_x_to_y(y = 1000, P = 0.1, pa = 0.05, pb = 0.25)
  )
)

```

The increase in efficiency is most obvious when making the range flexible to ensure the exact amount of tokens available is used.

Forcefully using all available tokens given a current price and max price with a flexible minimum price:

-   x = 100 BTC
-   y = 1000 ETH
-   Current Price, x/y = 0.1 BTC/ETH
-   min_price = ?? BTC/ETH (here, your position is 100% ETH).
-   max_price = 0.25 BTC/ETH (here, your position is 100% BTC)

We can use the `price_all_tokens()` with min price `pa = NULL` and noting our 
price is **not** in y/x (ETH/BTC) format; it is in x/y (BTC/ETH) format.

```{r}

price_all_tokens <- function(x, y, P, pa = NULL, pb = NULL, yx = TRUE){
  
  if(is.null(pa) & is.null(pb)){
    stop("min price pa OR max price pb must be provided")
  }
  
  if(!is.null(pa) & !is.null(pb)){
    stop("one of min price or max price should be unknown, NULL")
  }
  
   r <- list(
    amount_x = x,
    amount_y = y,
    current_price = P,
    min_price = NULL,
    max_price = NULL
  )
  
   if(!is.null(pa)){
     r$min_price <- pa
   } else { 
     r$max_price <- pb
   }
   
   # if min_price pa is given and prices are in Y/X format
   if(!is.null(pa) & yx == TRUE){
     
     f1 <- (y^2)/(x^2)
     f2 <- sqrt(pa) - sqrt(P) + (y/(sqrt(P)*x))
     pb <- f1 * (f2)^-2
     
     r$max_price <- pb
     
   }
   
   # if min_price pa is NOT given and prices are in Y/X format
   if(is.null(pa) & yx == TRUE){
     f1 <- y / (sqrt(pb) * x)
     f2 <- y / (sqrt(P) * x)
     pa <- (f1 + sqrt(P) - f2)^2
     r$min_price <- pa
   }
   
   # if min_price pa is given and prices are in X/Y format
   # use inverse and recursion
   if(!is.null(pa) & yx == FALSE){
     r$max_price <- match_tokens(x = x, y = y,
                                 P = P^-1, pb = pa^-1, yx = TRUE)$min_price^-1
   }
   
   # if min_price is NOT given and prices are in X/Y format
   # use inverse and recursion 
   if(is.null(pa) & yx == FALSE){
     r$min_price <- match_tokens(x = x, y = y,
                                 P = P^-1, pa = pb^-1, yx = TRUE)$max_price^-1
   }
  
   return(r)
}


reactable(
  as.data.frame(
    price_all_tokens(x = 100, y = 1000, P = 0.1, pa = NULL, pb = 0.25, yx = FALSE)
  )
)

```

Recall earlier, that the 0.05 - 0.25 range only required 79 BTC and 1000 ETH at a 0.1 price.

This 0.04 - 0.25 range uses all 100 BTC (and 1000 ETH) we have available, but it spreads liquidity wider and may be less capital efficient and result in less revenue per tick. We can't know a priori which range will be more profitable overall as that will depend on how much liquidity others are providing across which ticks and the changing prices of BTC/ETH.

But, nonetheless, the same liquidity `100 BTC * 1000 ETH = k = 100,000` is more efficient in the 0.04 - 0.25 range than it would be in the Uniswap v2 0 - Inf range given a set of N swaps that all occur in the 0.04 - 0.25 range paying 0.3% fees.

Note: The implied proportionality (1/0.04 = .25 * 100 BTC) of the clean min and max prices are because the amounts and current price are all proportional.

Given real world examples, you can get very odd looking min and max prices when forcing ranges to fit an amount of tokens.

## Real World Range Selection Confirmation

To both confirm the provided math and provide a real world reference example to range selection.

![Example Screenshot from 2022-09-28](v3_wbtc_eth_pricing.png){width="750"}

Consider the included image of Uniswap v3 WBTC-ETH 0.3% Pool. With the following parameters:

-   x = 100 WBTC
-   y = 1000.44 ETH (excuse the small difference, this is a result of tick spacing)
-   Current price, x/y, = 0.068 WBTC/ETH
-   Min Price = 0.006 WBTC/ETH
-   Max Price = 0.249 WBTC/ETH

Using the previously defined formulas, let's confirm that the min price 0.006 for this range.

Knowing that minimum is the inversion of maximum, we can use `match_max_to_tokens()` (see code)

```{r}
# yx 
max_yx <- match_max_to_tokens(x = 100, y = 1000.44, P = 0.068^-1, pa = 0.249^-1)$required_max_price


```

```{r}
min_tick <- get_closest_tick(0.05, tick_spacing = 60, decimal_adjustment = 1e10)$tick
max_tick <- get_closest_tick(0.25, tick_spacing = 60, decimal_adjustment = 1e10)$tick

tick_spread <- seq(min_tick, max_tick, by = 60)
plot(tick_spread, y = rep(1, length(tick_spread)), type = 'l')

```
